<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EQ Office Simulator 3D</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background-color: #111;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        /* UI Overlay for Instructions/Pause */
        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        #instructions {
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
            transition: background 0.2s;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            z-index: 11; /* Ensure clickable */
        }
        #start-btn:hover { background: #2563eb; }
        
        #sub-instructions {
            font-size: 16px;
            color: #ddd;
            line-height: 1.6;
            margin-top: 30px;
        }

        /* Heads Up Display */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 5;
            pointer-events: none; 
        }

        /* Persistent Controls at Bottom */
        #controls-hud {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            pointer-events: none;
            z-index: 4;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            transition: opacity 0.3s;
        }

        .hud-box {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            pointer-events: auto;
        }

        .score-val { color: #4ade80; }
        .score-val.low { color: #f87171; }

        #quit-btn {
            background: #ef4444;
            border: 1px solid #b91c1c;
            cursor: pointer;
            transition: background 0.2s;
        }
        #quit-btn:hover { background: #dc2626; }

        /* Dialogue / Interaction UI */
        #interaction-layer {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            z-index: 20;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translate(-50%, 50px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .speech-bubble {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border-left: 6px solid #3b82f6;
            position: relative;
        }

        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .npc-name {
            font-weight: 800;
            color: #1e293b;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .npc-mood {
            font-size: 0.9em;
            padding: 4px 10px;
            border-radius: 10px;
            background: #f1f5f9;
            color: #64748b;
            font-weight: bold;
        }

        .dialogue-text {
            font-size: 1.2em;
            color: #334155;
            line-height: 1.5;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .option-btn {
            background: rgba(30, 41, 59, 0.95);
            color: #e2e8f0;
            border: 1px solid #475569;
            padding: 15px 20px;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s;
            text-align: left;
            font-size: 1rem;
            display: flex;
            align-items: center;
        }
        .option-btn:active, .option-btn:hover {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .option-btn.full-width {
            grid-column: span 2;
            text-align: center;
            justify-content: center;
            background: #10b981;
            border-color: #059669;
            font-weight: bold;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 4;
            border: 2px solid rgba(0,0,0,0.2);
        }

        /* Game Over Screen */
        #game-over {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 30;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        #final-details { font-size: 20px; color: #aaa; margin-bottom: 10px; }
        #final-score { font-size: 60px; color: #4ade80; font-weight: bold; margin: 10px 0 20px 0; }
        #final-msg { font-size: 24px; color: #ccc; margin-bottom: 30px; max-width: 600px; padding: 0 20px; }
        #restart-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
        }
        #restart-btn:hover { background: #2563eb; }

        /* --- JOYSTICK STYLES --- */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            z-index: 15;
            display: none; /* Show via JS if mobile */
        }
        
        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(4px);
        }

        .joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        #mobile-look-hint {
            position: absolute;
            bottom: 50px;
            right: 40px;
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            display: none;
            pointer-events: none;
            text-align: right;
        }

        @media (max-width: 768px) {
            .options-grid { grid-template-columns: 1fr; }
            .option-btn.full-width { grid-column: span 1; }
            
            /* Adjust HUD for mobile */
            #hud { top: 10px; left: 10px; right: 10px; }
            .hud-box { padding: 10px 15px; font-size: 14px; }
            
            /* Hide desktop instructions on mobile */
            #controls-hud { display: none; }
        }
    </style>
    <!-- Import Map to resolve "three" in addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="container"></div>

    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- Instructions Overlay / Login -->
    <div id="blocker">
        <div id="instructions">
            <span style="font-size: 60px">üè¢</span><br>
            <b>Office EQ Simulator</b>
        </div>
        
        <div style="display:flex; flex-direction:column; align-items:center; gap:5px;">
            <button id="start-btn">Start Simulation</button>
        </div>

        <div id="sub-instructions">
            <p id="desktop-instruct"><b>W, A, S, D</b> to Move ‚Ä¢ <b>Mouse</b> to Look</p>
            <p id="mobile-instruct" style="display:none;"><b>Joystick</b> to Move ‚Ä¢ <b>Drag Screen</b> to Look</p>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-box">
            EQ Score: <span id="score-val" class="score-val">50</span>
        </div>
        <button id="quit-btn" class="hud-box">
            End Review üèÅ
        </button>
    </div>

    <!-- Persistent Instructions during Gameplay -->
    <div id="controls-hud">
        Navigate the office politics maze.<br>
        <b>W, A, S, D</b> to Move ‚Ä¢ <b>Mouse</b> to Look
    </div>

    <!-- Mobile Controls -->
    <div id="joystick-zone">
        <div class="joystick-base">
            <div class="joystick-stick" id="joystick-stick"></div>
        </div>
    </div>
    <div id="mobile-look-hint">
        Drag here to look ‚ûî
    </div>

    <!-- Interaction UI -->
    <div id="interaction-layer">
        <div class="speech-bubble">
            <div class="npc-header">
                <div class="npc-name" id="npc-name">Name</div>
                <div class="npc-mood" id="npc-mood">Mood: Neutral</div>
            </div>
            <div class="dialogue-text" id="npc-text">...</div>
        </div>
        <div class="options-grid" id="options-box">
            <!-- Buttons generated via JS -->
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <h1>Performance Review Complete</h1>
        <div id="final-details"></div>
        <div id="final-score">50</div>
        <div id="final-msg">...</div>
        <button id="restart-btn" onclick="location.reload()">Start New Career</button>
    </div>

    <!-- Modules -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const npcs = [];
        let currentInteractingNPC = null;
        let eqScore = 50;
        let interactionsCount = 0;
        
        // Mobile State
        let isMobile = false;
        let joystickActive = false;
        let joystickData = { x: 0, y: 0 }; // -1 to 1
        let touchLookStart = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 }; // Pitch, Yaw

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const startBtn = document.getElementById('start-btn');
        const interactionLayer = document.getElementById('interaction-layer');
        const npcNameUI = document.getElementById('npc-name');
        const npcMoodUI = document.getElementById('npc-mood');
        const npcTextUI = document.getElementById('npc-text');
        const optionsBox = document.getElementById('options-box');
        const scoreValUI = document.getElementById('score-val');
        const quitBtn = document.getElementById('quit-btn');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreUI = document.getElementById('final-score');
        const finalMsgUI = document.getElementById('final-msg');
        const finalDetailsUI = document.getElementById('final-details');
        const controlsHud = document.getElementById('controls-hud');
        
        // Mobile Elements
        const joystickZone = document.getElementById('joystick-zone');
        const joystickStick = document.getElementById('joystick-stick');
        const mobileInstruct = document.getElementById('mobile-instruct');
        const desktopInstruct = document.getElementById('desktop-instruct');
        const mobileLookHint = document.getElementById('mobile-look-hint');

        init();
        animate();

        function init() {
            // Detect Mobile
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if(isMobile) {
                desktopInstruct.style.display = 'none';
                mobileInstruct.style.display = 'block';
                controlsHud.style.display = 'none';
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // Dark outside
            scene.fog = new THREE.Fog(0x111111, 0, 30);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Ceiling Lights
            const lightPositions = [
                [0, 3.8, 0], [-10, 3.8, 10], [10, 3.8, 10], 
                [-10, 3.8, -10], [10, 3.8, -10]
            ];
            
            lightPositions.forEach(pos => {
                const pointLight = new THREE.PointLight(0xffffee, 0.6, 25);
                pointLight.position.set(...pos);
                const bulbGeo = new THREE.BoxGeometry(2, 0.1, 2);
                const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
                const bulb = new THREE.Mesh(bulbGeo, bulbMat);
                bulb.position.set(pos[0], 3.95, pos[2]);
                scene.add(bulb);
                scene.add(pointLight);
            });

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 1.6;
            camera.rotation.order = 'YXZ'; // Important for custom look control

            // Controls
            // On mobile we won't use PointerLockControls, we'll use custom logic
            if (!isMobile) {
                controls = new PointerLockControls(camera, document.body);
                scene.add(controls.getObject());
            } else {
                // Mobile custom camera container
                const cameraHolder = new THREE.Object3D();
                cameraHolder.add(camera);
                scene.add(cameraHolder);
                // Mock the 'controls' object for consistency
                controls = {
                    isLocked: false,
                    lock: () => { 
                        controls.isLocked = true; 
                        blocker.style.display = 'none';
                        joystickZone.style.display = 'block';
                        mobileLookHint.style.display = 'block';
                    },
                    unlock: () => { 
                        controls.isLocked = false; 
                        blocker.style.display = 'flex';
                        joystickZone.style.display = 'none';
                        mobileLookHint.style.display = 'none';
                    },
                    getObject: () => cameraHolder
                };
                setupMobileControls();
            }

            // START GAME HANDLER
            startBtn.addEventListener('click', function() {
                controls.lock();
            });

            // Handle Quit Button
            quitBtn.addEventListener('click', function(e) {
                endGame();
            });

            // Desktop Lock Listeners (only add if valid object)
            if(!isMobile) {
                controls.addEventListener('lock', function () {
                    blocker.style.display = 'none';
                    interactionLayer.style.display = 'none';
                });

                controls.addEventListener('unlock', function () {
                    if (currentInteractingNPC !== null) {
                        blocker.style.display = 'none';
                    } else if (gameOverScreen.style.display !== 'flex') {
                        blocker.style.display = 'flex';
                    }
                });
            }

            // Input Listeners (Desktop)
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };

            if (!isMobile) {
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
            }

            // --- WORLD GENERATION ---
            createCarpet();
            createCeiling();
            
            // Room Walls
            createWall(0, 2, -20, 40, 4, 1);
            createWall(0, 2, 20, 40, 4, 1);
            createWall(-20, 2, 0, 1, 4, 40);
            createWall(20, 2, 0, 1, 4, 40);

            // Furniture Generator
            for (let i = 0; i < 14; i++) {
                const x = (Math.random() * 34) - 17;
                const z = (Math.random() * 34) - 17;
                createDesk(x, z);
            }

            // --- NPC GENERATION ---
            const scenarios = [
                {
                    pos: [0, 0, -10], color: 0xef4444, name: "Manager Karen", mood: "Hostile",
                    text: "There you are! This report is absolute GARBAGE! Did you even try, or are you just wasting my budget?",
                    options: [
                        { text: "Chill out! You didn't give me clear instructions.", score: -10, outcome: "Excuse me? Get out of my office!" },
                        { text: "I hear your frustration. Let's look at the gaps so I can fix them.", score: +10, outcome: "Hmph. Fine. Sit down." },
                        { text: "It's not my fault, IT systems were down.", score: -5, outcome: "I don't want excuses, I want results!" }
                    ]
                },
                {
                    pos: [10, 0, 5], color: 0x22c55e, name: "Intern Tim", mood: "Panicked",
                    text: "I... I think I deleted the database. The screen went black. I'm going to get fired, aren't I?",
                    options: [
                        { text: "Wow, that was stupid. Good luck explaining that.", score: -10, outcome: "Oh god... I can't breathe..." },
                        { text: "Hey, breathe. It's likely just a connection error. Let's check.", score: +10, outcome: "Really? Okay... let's check." },
                        { text: "You should probably start updating your resume.", score: -15, outcome: "Tim starts hyperventilating." }
                    ]
                },
                {
                    pos: [-10, 0, 5], color: 0xeab308, name: "Steve from Acct.", mood: "Sarcastic",
                    text: "Oh, leaving at 5 PM exactly? Must be nice to not have actual work to do.",
                    options: [
                        { text: "Mind your own business, Steve.", score: -5, outcome: "Touchy today, aren't we?" },
                        { text: "I prioritize efficiency over staying late.", score: +10, outcome: "Fair enough, I guess." },
                        { text: "Sorry, I'll stay longer.", score: -2, outcome: "Yeah, you better." }
                    ]
                },
                {
                    pos: [15, 0, -5], color: 0xd946ef, name: "Gossip Glenda", mood: "Sneaky",
                    text: "Psst! Did you hear? The CEO was seen crying in the elevator with a rubber duck.",
                    options: [
                        { text: "Omg really? Tell me everything!", score: -5, outcome: "I know right?! So weird." },
                        { text: "I prefer not to speculate on rumors.", score: +10, outcome: "Ugh, you're no fun." },
                        { text: "My only office romance is with this coffee.", score: +5, outcome: "Haha, true that!" }
                    ]
                },
                {
                    pos: [-15, 0, -5], color: 0x06b6d4, name: "Dev Dave", mood: "Condescending",
                    text: "It's not 'broken', it's 'eventually consistent'. You wouldn't understand the architecture.",
                    options: [
                        { text: "Stop speaking nerd and fix it!", score: -10, outcome: "You just don't get it." },
                        { text: "I trust your expertise. Can you give me a simpler timeline?", score: +10, outcome: "Sure, I can patch it by noon." },
                        { text: "Cool story bro.", score: -5, outcome: "Whatever." }
                    ]
                },
                {
                    pos: [5, 0, 10], color: 0xf97316, name: "Hungry Harry", mood: "Guilty",
                    text: "(Mouth full) Oh... uh... I thought this sandwich labeled 'DO NOT EAT' was for everyone.",
                    options: [
                        { text: "Spit it out! That's mine!", score: -10, outcome: "Okay geez! (Spits on floor)" },
                        { text: "That was mine. Please check labels next time. You owe me a taco.", score: +10, outcome: "Deal. Taco Tuesday on me." },
                        { text: "I put ghost peppers in that.", score: +5, outcome: "The... WHAT?! (Runs for water)" }
                    ]
                },
                {
                    pos: [-5, 0, 12], color: 0x1e3a8a, name: "Brenda", mood: "Exhausted",
                    text: "The printer is speaking to me. It says 'Paper Jam' is a metaphor for my life.",
                    options: [
                        { text: "You look terrible. Get it together.", score: -15, outcome: "I'm just a paper jam..." },
                        { text: "Go home, Brenda. I'll cover you.", score: +15, outcome: "You're an angel." },
                        { text: "Ask it for lottery numbers.", score: +5, outcome: "It says... 42." }
                    ]
                }
            ];

            scenarios.forEach(s => {
                createHumanoidNPC(new THREE.Vector3(...s.pos), s.color, s.name, s.mood, s.text, s.options);
            });

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function setupMobileControls() {
            // JOYSTICK
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if(!joystickActive) return;

                const touch = e.changedTouches[0];
                const rect = joystickZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Vector from center
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                
                // Clamp magnitude
                const maxDist = 40; // Stick radius limit
                const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist > maxDist) {
                    const factor = maxDist / dist;
                    dx *= factor;
                    dy *= factor;
                }

                // Move visual stick
                joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                // Normalize for velocity (-1 to 1)
                joystickData.x = dx / maxDist;
                joystickData.y = dy / maxDist;
            }, {passive: false});

            const endJoystick = (e) => {
                joystickActive = false;
                joystickStick.style.transform = `translate(-50%, -50%)`;
                joystickData.x = 0;
                joystickData.y = 0;
            };

            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            // CAMERA LOOK
            document.body.addEventListener('touchstart', (e) => {
                if(!controls.isLocked) return;
                // Ignore touches on joystick zone or buttons
                if(e.target.closest('#joystick-zone') || e.target.closest('button')) return;

                const touch = e.changedTouches[0];
                touchLookStart.x = touch.clientX;
                touchLookStart.y = touch.clientY;
            }, {passive: false});

            document.body.addEventListener('touchmove', (e) => {
                if(!controls.isLocked) return;
                if(e.target.closest('#joystick-zone') || e.target.closest('button')) return;

                const touch = e.changedTouches[0];
                const dx = touch.clientX - touchLookStart.x;
                const dy = touch.clientY - touchLookStart.y;

                // Rotate logic manually since we aren't using PointerLock
                const sensitivity = 0.005;
                
                // Yaw (Rotation around Y) - Apply to container object
                const playerObj = controls.getObject();
                playerObj.rotation.y -= dx * sensitivity;

                // Pitch (Rotation around X) - Apply to camera
                cameraRotation.x -= dy * sensitivity;
                // Clamp Pitch
                cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                camera.rotation.x = cameraRotation.x;

                // Reset for next frame delta
                touchLookStart.x = touch.clientX;
                touchLookStart.y = touch.clientY;
            }, {passive: false});
        }

        function createCarpet() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#334155';
            ctx.fillRect(0, 0, 512, 512);
            
            for(let i=0; i<50000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.fillStyle = Math.random() > 0.5 ? '#475569' : '#1e293b';
                ctx.fillRect(x, y, 2, 2);
            }
            
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for(let i=0; i<=512; i+=64) {
                ctx.moveTo(i, 0); ctx.lineTo(i, 512);
                ctx.moveTo(0, i); ctx.lineTo(512, i);
            }
            ctx.stroke();

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(10, 10);
            
            const geo = new THREE.PlaneGeometry(40, 40);
            geo.rotateX(-Math.PI/2);
            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createCeiling() {
            const geo = new THREE.PlaneGeometry(40, 40);
            geo.rotateX(Math.PI/2); 
            const mat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.9 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = 4;
            scene.add(mesh);
        }

        function createWall(x, y, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: 0xe2e8f0 }); 
            const wall = new THREE.Mesh(geo, mat);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            
            const baseGeo = new THREE.BoxGeometry(w + 0.1, 0.2, d + 0.1);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x333 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.set(x, 0.1, z);
            scene.add(base);
        }

        function createDesk(x, z) {
            const group = new THREE.Group();
            
            const topMat = new THREE.MeshStandardMaterial({ color: 0xd4a373, roughness: 0.5 });
            const top = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.08, 1.2), topMat);
            top.position.y = 0.75;
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);

            const legMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.2 });
            const legGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.75);
            [[-1, -0.5], [1, -0.5], [-1, 0.5], [1, 0.5]].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(pos[0], 0.375, pos[1]);
                group.add(leg);
            });

            const screen = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.05), new THREE.MeshStandardMaterial({ color: 0x111 }));
            screen.position.set(0, 1.05, -0.3);
            group.add(screen);
            
            const stand = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.05), new THREE.MeshStandardMaterial({ color: 0x333 }));
            stand.position.set(0, 0.85, -0.3);
            group.add(stand);

            group.position.set(x, 0, z);
            scene.add(group);
        }

        function createHumanoidNPC(position, shirtColor, name, mood, dialogue, options) {
            const group = new THREE.Group();
            const skinColor = 0xffccaa; 

            const shirtMat = new THREE.MeshStandardMaterial({ color: shirtColor });
            const skinMat = new THREE.MeshStandardMaterial({ color: skinColor });
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 }); 
            
            const legGeo = new THREE.BoxGeometry(0.22, 0.85, 0.22);
            const leftLeg = new THREE.Mesh(legGeo, pantsMat);
            leftLeg.position.set(-0.15, 0.425, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, pantsMat);
            rightLeg.position.set(0.15, 0.425, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);

            const torsoGeo = new THREE.BoxGeometry(0.55, 0.65, 0.3);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.set(0, 1.15, 0);
            torso.castShadow = true;
            group.add(torso);

            const headGeo = new THREE.BoxGeometry(0.25, 0.28, 0.25);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.set(0, 1.65, 0);
            head.castShadow = true;
            group.add(head);

            const armGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
            const leftArm = new THREE.Mesh(armGeo, shirtMat);
            leftArm.position.set(-0.38, 1.15, 0);
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, shirtMat);
            rightArm.position.set(0.38, 1.15, 0);
            group.add(rightArm);

            const marker = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.1, 0),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            marker.position.y = 2.2;
            marker.name = 'marker';
            group.add(marker);

            group.position.copy(position);
            group.rotation.y = (Math.random() - 0.5) * 1.5;

            scene.add(group);

            npcs.push({
                group: group,
                name: name,
                mood: mood,
                dialogue: dialogue,
                options: options,
                interacted: false
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            if (controls.isLocked === true) {
                
                // Decay velocity
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // Calculate Direction
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                
                // MOBILE OVERRIDE
                if(isMobile) {
                    direction.x = joystickData.x; // Left/Right
                    direction.z = joystickData.y; // Forward/Back (Corrected: Up is negative Y, which makes direction negative, increasing velocity, moving forward)
                } else {
                    direction.normalize(); // Only needed for keyboard discrete values
                }

                // Move speed multiplier
                const speed = 40.0;

                if (moveForward || moveBackward || joystickData.y !== 0) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight || joystickData.x !== 0) velocity.x -= direction.x * speed * delta;

                // Apply movement
                if(isMobile) {
                    // For mobile custom logic, we move relative to player object
                    const playerObj = controls.getObject();
                    
                    // Move Forward/Back (Z axis of object)
                    playerObj.translateZ(-velocity.z * delta);
                    // Move Left/Right (X axis of object)
                    playerObj.translateX(-velocity.x * delta);
                } else {
                    // Standard PointerLockControls
                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);
                }

                checkNPCProximity();
            }

            // NPC Animations
            npcs.forEach(npc => {
                const marker = npc.group.getObjectByName("marker");
                if(marker) {
                    marker.position.y = 2.2 + Math.sin(time * 0.005) * 0.1;
                    marker.rotation.y += 0.05;
                    marker.visible = !npc.interacted;
                }
                if (!npc.interacted && controls.isLocked) {
                    const dist = camera.getWorldPosition(new THREE.Vector3()).distanceTo(npc.group.position);
                    if(dist < 8) {
                        // Look at camera
                        const camPos = camera.getWorldPosition(new THREE.Vector3());
                        npc.group.lookAt(camPos.x, npc.group.position.y, camPos.z);
                    }
                }
            });

            prevTime = time;
            renderer.render(scene, camera);
        }

        function checkNPCProximity() {
            if(currentInteractingNPC) return;

            const playerPos = controls.getObject().position; // Works for both controls

            for (let npc of npcs) {
                if (npc.interacted) continue;

                const dist = playerPos.distanceTo(npc.group.position);
                if (dist < 2.5) {
                    startInteraction(npc);
                    break; 
                }
            }
        }

        function startInteraction(npc) {
            currentInteractingNPC = npc;
            controls.unlock();
            
            // Hide persistent instructions
            if(!isMobile) controlsHud.style.opacity = '0';
            else {
                joystickZone.style.display = 'none';
                mobileLookHint.style.display = 'none';
            }

            npcNameUI.textContent = npc.name;
            npcMoodUI.textContent = `Mood: ${npc.mood}`;
            npcTextUI.textContent = `"${npc.dialogue}"`;
            
            optionsBox.innerHTML = '';

            const labels = ['A', 'B', 'C'];

            npc.options.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                const label = labels[index] ? labels[index] + ". " : "";
                btn.textContent = label + option.text;
                btn.onclick = () => resolveInteraction(npc, option);
                optionsBox.appendChild(btn);
            });

            interactionLayer.style.display = 'flex';
        }

        function resolveInteraction(npc, option) {
            eqScore += option.score;
            interactionsCount++;
            scoreValUI.textContent = eqScore;
            
            if(eqScore < 50) scoreValUI.classList.add('low');
            else scoreValUI.classList.remove('low');

            npcTextUI.innerHTML = `<b>${npc.name}:</b><br>"${option.outcome}"`;
            
            optionsBox.innerHTML = '';
            const leaveBtn = document.createElement('button');
            leaveBtn.className = 'option-btn full-width';
            leaveBtn.textContent = 'End Conversation';
            leaveBtn.onclick = () => endInteraction(npc);
            optionsBox.appendChild(leaveBtn);

            npc.interacted = true;
            const marker = npc.group.getObjectByName("marker");
            if(marker) marker.visible = false;

            npc.group.children.forEach(mesh => {
                if(mesh.material && mesh.name !== 'marker') {
                    mesh.material.color.setHex(0x555555);
                }
            });
        }

        function endInteraction(npc) {
            currentInteractingNPC = null;
            interactionLayer.style.display = 'none';
            
            if(!isMobile) controlsHud.style.opacity = '1';
            
            if(interactionsCount >= npcs.length) {
                endGame();
            } else {
                controls.lock(); 
            }
        }

        function endGame() {
            controls.unlock();
            blocker.style.display = 'none';
            interactionLayer.style.display = 'none';
            if(!isMobile) controlsHud.style.display = 'none';
            else {
                 joystickZone.style.display = 'none';
                 mobileLookHint.style.display = 'none';
            }
            
            gameOverScreen.style.display = 'flex';
            finalDetailsUI.innerHTML = "";
            finalScoreUI.textContent = eqScore;
            
            let msg = "";
            if(eqScore >= 100) msg = "CEO Material! Your emotional intelligence is unmatched.";
            else if(eqScore >= 70) msg = "Great job! You're a solid team player.";
            else if(eqScore >= 40) msg = "You survived, but maybe take a soft skills workshop.";
            else msg = "You have been reported to HR. Please clear your desk.";
            
            finalMsgUI.textContent = msg;
        }

        window.resolveInteraction = resolveInteraction;
        window.endInteraction = endInteraction;
        window.endGame = endGame;
    </script>
</body>
</html>
